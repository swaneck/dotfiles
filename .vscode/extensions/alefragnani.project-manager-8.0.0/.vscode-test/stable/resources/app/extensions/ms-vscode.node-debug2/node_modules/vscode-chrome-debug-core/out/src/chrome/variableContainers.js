"use strict";
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_debugadapter_1 = require("vscode-debugadapter");
const utils = require("../utils");
const chromeUtils = require("./chromeUtils");
const errors = require("../errors");
class BaseVariableContainer {
    constructor(chromeDebugAdapter, objectId, evaluateName) {
        this.chromeDebugAdapter = chromeDebugAdapter;
        this.objectId = objectId;
        this.evaluateName = evaluateName;
    }
    expand(filter, start, count) {
        return this.chromeDebugAdapter.getVariablesForObjectId(this.objectId, this.evaluateName, filter, start, count);
    }
    setValue(name, value) {
        return utils.errP('setValue not supported by this variable type');
    }
}
exports.BaseVariableContainer = BaseVariableContainer;
class PropertyContainer extends BaseVariableContainer {
    setValue(name, value) {
        return this.setPropertyValue(this.objectId, name, value);
    }
    setPropertyValue(objectId, propName, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const setPropertyValueFn = `function() { return this["${propName}"] = ${value} }`;
            const response = yield this.chromeDebugAdapter.chrome.Runtime.callFunctionOn({
                objectId, functionDeclaration: setPropertyValueFn,
                silent: true
            }).catch(error => Promise.reject(errors.errorFromEvaluate(error.message)));
            if (response.exceptionDetails) {
                const errMsg = chromeUtils.errorMessageFromExceptionDetails(response.exceptionDetails);
                return Promise.reject(errors.errorFromEvaluate(errMsg));
            }
            else {
                // Temporary, Microsoft/vscode#12019
                return chromeUtils.remoteObjectToValue(response.result).value;
            }
        });
    }
}
exports.PropertyContainer = PropertyContainer;
class LoggedObjectsContainer extends BaseVariableContainer {
    constructor(chromeDebugAdapter, args) {
        super(chromeDebugAdapter, undefined);
        this.args = args;
    }
    expand(filter, start, count) {
        return Promise.all(this.args.map((arg, i) => this.chromeDebugAdapter.remoteObjectToVariable('' + i, arg, undefined, /*stringify=*/ false, 'repl')));
    }
}
exports.LoggedObjectsContainer = LoggedObjectsContainer;
class ScopeContainer extends BaseVariableContainer {
    constructor(adapter, frameId, origScopeIndex, objectId, thisObj, returnValue) {
        super(adapter, objectId, '');
        this._thisObj = thisObj;
        this._returnValue = returnValue;
        this._frameId = frameId;
        this._origScopeIndex = origScopeIndex;
    }
    /**
     * Call super then insert the 'this' object if needed
     */
    expand(filter, start, count) {
        // No filtering in scopes right now
        return super.expand('all', start, count).then(variables => {
            if (this._thisObj) {
                // If this is a scope that should have the 'this', prop, insert it at the top of the list
                return this.insertRemoteObject(variables, 'this', this._thisObj);
            }
            return variables;
        }).then(variables => {
            if (this._returnValue) {
                return this.insertRemoteObject(variables, 'Return value', this._returnValue);
            }
            return variables;
        });
    }
    setValue(name, value) {
        return this.chromeDebugAdapter.setVariableValue(this._frameId, this._origScopeIndex, name, value);
    }
    insertRemoteObject(variables, name, obj) {
        return this.chromeDebugAdapter.remoteObjectToVariable(name, obj).then(variable => {
            variables.unshift(variable);
            return variables;
        });
    }
}
exports.ScopeContainer = ScopeContainer;
class ExceptionContainer extends PropertyContainer {
    constructor(adapter, objectId, exception) {
        super(adapter, exception.objectId, undefined);
        this._exception = exception;
    }
    /**
     * Expand the exception as if it were a Scope
     */
    static create(adapter, exception) {
        return exception.objectId ?
            new ExceptionContainer(adapter, exception.objectId, exception) :
            new ExceptionValueContainer(adapter, exception);
    }
}
exports.ExceptionContainer = ExceptionContainer;
/**
 * For when a value is thrown instead of an object
 */
class ExceptionValueContainer extends ExceptionContainer {
    constructor(chromeDebugAdapter, exception) {
        super(chromeDebugAdapter, 'EXCEPTION_ID', exception);
    }
    /**
     * Make up a fake 'Exception' property to hold the thrown value, displayed under the Exception Scope
     */
    expand(filter, start, count) {
        const excValuePropDescriptor = { name: 'Exception', value: this._exception };
        return this.chromeDebugAdapter.propertyDescriptorToVariable(excValuePropDescriptor)
            .then(variable => [variable]);
    }
}
exports.ExceptionValueContainer = ExceptionValueContainer;
class VariableHandles {
    constructor() {
        this._variableHandles = new vscode_debugadapter_1.Handles(1);
        this._consoleVariableHandles = new vscode_debugadapter_1.Handles(1e5);
    }
    onPaused() {
        // Only reset the variableHandles, the console vars are still visible
        this._variableHandles.reset();
    }
    create(value, context = 'variables') {
        return this.getHandles(context).create(value);
    }
    get(handle) {
        return this._variableHandles.get(handle) || this._consoleVariableHandles.get(handle);
    }
    getHandles(context) {
        return context === 'repl' ?
            this._consoleVariableHandles :
            this._variableHandles;
    }
}
exports.VariableHandles = VariableHandles;

//# sourceMappingURL=variableContainers.js.map
