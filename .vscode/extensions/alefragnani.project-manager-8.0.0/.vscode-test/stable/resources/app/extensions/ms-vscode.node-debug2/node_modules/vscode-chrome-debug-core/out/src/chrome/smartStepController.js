"use strict";
/*---------------------------------------------------------
* Copyright (C) Microsoft Corporation. All rights reserved.
*--------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const vscode_debugadapter_1 = require("vscode-debugadapter");
class SmartStepController {
    constructor(launchAttachArgs, _chromeDebugAdapter, _pathTransformer, _sourceMapTransformer) {
        this._chromeDebugAdapter = _chromeDebugAdapter;
        this._pathTransformer = _pathTransformer;
        this._sourceMapTransformer = _sourceMapTransformer;
        this._smartStepCount = 0;
        this._smartStepEnabled = launchAttachArgs.smartStep;
    }
    get smartStepEnabled() {
        return this._smartStepEnabled;
    }
    toggleSmartStep() {
        this._smartStepEnabled = !this._smartStepEnabled;
    }
    /**
     * SmartSteps through the give frame if needed. Returns whether a smartStep happened.
     */
    maybeSmartStep(frame) {
        return __awaiter(this, void 0, void 0, function* () {
            const should = yield this.shouldSmartStep(frame);
            if (should) {
                this._smartStepCount++;
                yield this._chromeDebugAdapter.stepIn(false);
                return true;
            }
            else {
                if (this._smartStepCount > 0) {
                    vscode_debugadapter_1.logger.log(`SmartStep: Skipped ${this._smartStepCount} steps`);
                    this._smartStepCount = 0;
                }
                return false;
            }
        });
    }
    shouldSmartStep(frame) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._smartStepEnabled)
                return Promise.resolve(false);
            const stackFrame = this._chromeDebugAdapter.callFrameToStackFrame(frame);
            const clientPath = this._pathTransformer.getClientPathFromTargetPath(stackFrame.source.path) || stackFrame.source.path;
            const mapping = yield this._sourceMapTransformer.mapToAuthored(clientPath, frame.location.lineNumber, frame.location.columnNumber);
            return !mapping;
        });
    }
}
exports.SmartStepController = SmartStepController;

//# sourceMappingURL=smartStepController.js.map
